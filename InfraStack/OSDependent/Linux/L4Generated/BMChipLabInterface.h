/*****************************************************************************
 * Automatically generated by Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0) - DO NOT EDIT!
 * Generated at 11/19/2009 12:56:05 AM
 *
 * Project : Ofer
 * Module  : ChipLabInterface
 * Author  : Elad Ben-Israel
 * Date    : 14/5/2006
 * Purpose : Common bitman definitions for LTA
 *****************************************************************************/

#if !defined(_BITMAN_BMCHIPLABINTERFACE_H_)
#define _BITMAN_BMCHIPLABINTERFACE_H_


/*lint ++flb */
// Include the Bitman common header file
#include "BitmanCommon.h"

// Include headers generated from XMLs (the source is both XMLs and the command-line)
#include "PeekPokeBuff.h"
#include "BM_Chiplab_Common.h"

// Include user C header files

// Include user C header files (supplied in the command-line)


// Bitman version Accessor...
#ifndef BM_BITMAN_VERSION
#define BM_BITMAN_VERSION 	"Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0)"
#endif 

// Definitions

typedef UINT8 BufferUint32[4];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _Entry;
} BMS_BufferUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _Entry;
} BMS_BufferUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'BufferUint32' Type: 'BufferUint32', Top-level, Non-instance, No bitoff root
#define BM_BufferUint32_Entry_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
}

#define BM_BufferUint32_Entry_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal271_tmp_bitoff;\
	BM_BufferUint32_Entry_GET_POS( base_ptr, out_ptr, bmlocal271_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal271_tmp_bitoff);\
}

#define BM_BufferUint32_Entry_POS_ALIGNED 0

// Alignment of BufferUint32_Entry: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_BufferUint32_Entry_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_BufferUint32_Entry_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal272_my_ptr;\
	UINT bmlocal273_my_bitoff;\
	BM_BufferUint32_Entry_GET_POS( base_ptr, bmlocal272_my_ptr, bmlocal273_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal272_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal272_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal272_my_ptr, bmlocal273_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_BufferUint32_Entry_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT32 bmlocal274_tmp_var;
	BM_BufferUint32_Entry_GET( base_ptr, bmlocal274_tmp_var );
	return bmlocal274_tmp_var;
}

#define BM_BufferUint32_Entry_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal275_my_ptr;\
	UINT bmlocal276_my_bitoff;\
	BM_BufferUint32_Entry_GET_POS( base_ptr, bmlocal275_my_ptr, bmlocal276_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal275_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal275_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal275_my_ptr, bmlocal276_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// BufferUint32_Entry: IS_DEFAULT accessor is not defined because no default value was specified.
// BufferUint32_Entry: SET_DEFAULT accessor is not defined because no default value was specified.
// BufferUint32_Entry: IS_RESET accessor is not defined because no reset value was specified.
// BufferUint32_Entry: SET_RESET accessor is not defined because no reset value was specified.
// BufferUint32_Entry: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// BufferUint32_Entry: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_BufferUint32_Entry_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal277_out_val;\
	BM_BufferUint32_Entry_GET( base_ptr, bmlocal277_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Entry", 32, (UINT)(bmlocal277_out_val), "%d", 1);\
}

#define BM_BufferUint32_Entry_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_BufferUint32_Entry_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_BufferUint32_Entry_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal278_my_ptr;\
	UINT bmlocal279_my_bitoff;\
	BM_BufferUint32_Entry_GET_POS( base_ptr, bmlocal278_my_ptr, bmlocal279_my_bitoff );\
	(*((UINT32*)bmlocal278_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal279_my_bitoff );\
}

// BufferUint32_Entry: Validation accessors are not defined because validation condition was not specified.
#define BM_BufferUint32_Entry_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal280_tmp_bits;\
	BM_BufferUint32_Entry_GET_SIZE( base_ptr, out_bytes, bmlocal280_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal280_tmp_bits );\
}

#define BM_BufferUint32_Entry_BYTES_SIZE 4

#define BM_BufferUint32_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_BufferUint32_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal283_tmp_bits;\
	BM_BufferUint32_GET_SIZE( base_ptr, out_bytes, bmlocal283_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal283_tmp_bits );\
}

#define BM_BufferUint32_BYTES_SIZE 4

#define BM_BufferUint32_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "BufferUint32", 1);\
	BM_BufferUint32_Entry_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_BufferUint32_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_BufferUint32_DUMP_DEPTH( base_ptr, 0 );\
}


typedef enum
{
	False = 0,
	True = 1
} Boolean;

#define CHIPLAB_RESPONSE_REASON_LENGTH (128)

#define CHIPLAB_RESPONSE_ARGS_NO (3)

typedef UINT8 ChipLabResponse[152];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _Ack; //0 - nack, 1 - ack
	UINT32 _Code;
	UINT32 _ReasonLength; //The length of the reason string
	BMS_BufferString _Reason[128];
	BMS_BufferUint32 _Args[3];
} BMS_ChipLabResponse;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	BMS_BufferUint32 _Args[3];
	BMS_BufferString _Reason[128];
	UINT32 _ReasonLength; //The length of the reason string
	UINT32 _Code;
	UINT32 _Ack; //0 - nack, 1 - ack
} BMS_ChipLabResponse;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'ChipLabResponse' Type: 'ChipLabResponse', Top-level, Non-instance, No bitoff root
#define BM_ChipLabResponse_Ack_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
}

#define BM_ChipLabResponse_Ack_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal284_tmp_bitoff;\
	BM_ChipLabResponse_Ack_GET_POS( base_ptr, out_ptr, bmlocal284_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal284_tmp_bitoff);\
}

#define BM_ChipLabResponse_Ack_POS_ALIGNED 0

// Alignment of ChipLabResponse_Ack: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_ChipLabResponse_Ack_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Ack_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal285_my_ptr;\
	UINT bmlocal286_my_bitoff;\
	BM_ChipLabResponse_Ack_GET_POS( base_ptr, bmlocal285_my_ptr, bmlocal286_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal285_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal285_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal285_my_ptr, bmlocal286_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_ChipLabResponse_Ack_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT32 bmlocal287_tmp_var;
	BM_ChipLabResponse_Ack_GET( base_ptr, bmlocal287_tmp_var );
	return bmlocal287_tmp_var;
}

#define BM_ChipLabResponse_Ack_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal288_my_ptr;\
	UINT bmlocal289_my_bitoff;\
	BM_ChipLabResponse_Ack_GET_POS( base_ptr, bmlocal288_my_ptr, bmlocal289_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal288_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal288_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal288_my_ptr, bmlocal289_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// ChipLabResponse_Ack: IS_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Ack: SET_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Ack: IS_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Ack: SET_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Ack: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChipLabResponse_Ack: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChipLabResponse_Ack_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal290_out_val;\
	BM_ChipLabResponse_Ack_GET( base_ptr, bmlocal290_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Ack", 32, (UINT)(bmlocal290_out_val), "%d", 1);\
}

#define BM_ChipLabResponse_Ack_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Ack_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_ChipLabResponse_Ack_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal291_my_ptr;\
	UINT bmlocal292_my_bitoff;\
	BM_ChipLabResponse_Ack_GET_POS( base_ptr, bmlocal291_my_ptr, bmlocal292_my_bitoff );\
	(*((UINT32*)bmlocal291_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal292_my_bitoff );\
}

// ChipLabResponse_Ack: Validation accessors are not defined because validation condition was not specified.
#define BM_ChipLabResponse_Ack_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal293_tmp_bits;\
	BM_ChipLabResponse_Ack_GET_SIZE( base_ptr, out_bytes, bmlocal293_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal293_tmp_bits );\
}

#define BM_ChipLabResponse_Ack_BYTES_SIZE 4

#define BM_ChipLabResponse_Code_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal296_acc_bytes;\
	UINT bmlocal297_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal296_acc_bytes = 4;\
	bmlocal297_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal296_acc_bytes );\
	out_bitoff += bmlocal297_acc_bits;\
}

#define BM_ChipLabResponse_Code_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal298_tmp_bitoff;\
	BM_ChipLabResponse_Code_GET_POS( base_ptr, out_ptr, bmlocal298_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal298_tmp_bitoff);\
}

#define BM_ChipLabResponse_Code_POS_ALIGNED 4

// Alignment of ChipLabResponse_Code: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_ChipLabResponse_Code_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Code_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal299_my_ptr;\
	UINT bmlocal300_my_bitoff;\
	BM_ChipLabResponse_Code_GET_POS( base_ptr, bmlocal299_my_ptr, bmlocal300_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal299_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal299_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal299_my_ptr, bmlocal300_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_ChipLabResponse_Code_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT32 bmlocal301_tmp_var;
	BM_ChipLabResponse_Code_GET( base_ptr, bmlocal301_tmp_var );
	return bmlocal301_tmp_var;
}

#define BM_ChipLabResponse_Code_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal302_my_ptr;\
	UINT bmlocal303_my_bitoff;\
	BM_ChipLabResponse_Code_GET_POS( base_ptr, bmlocal302_my_ptr, bmlocal303_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal302_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal302_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal302_my_ptr, bmlocal303_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// ChipLabResponse_Code: IS_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Code: SET_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Code: IS_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Code: SET_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Code: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChipLabResponse_Code: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChipLabResponse_Code_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal304_out_val;\
	BM_ChipLabResponse_Code_GET( base_ptr, bmlocal304_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Code", 32, (UINT)(bmlocal304_out_val), "%d", 1);\
}

#define BM_ChipLabResponse_Code_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Code_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_ChipLabResponse_Code_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal305_my_ptr;\
	UINT bmlocal306_my_bitoff;\
	BM_ChipLabResponse_Code_GET_POS( base_ptr, bmlocal305_my_ptr, bmlocal306_my_bitoff );\
	(*((UINT32*)bmlocal305_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal306_my_bitoff );\
}

// ChipLabResponse_Code: Validation accessors are not defined because validation condition was not specified.
#define BM_ChipLabResponse_Code_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal307_tmp_bits;\
	BM_ChipLabResponse_Code_GET_SIZE( base_ptr, out_bytes, bmlocal307_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal307_tmp_bits );\
}

#define BM_ChipLabResponse_Code_BYTES_SIZE 4

#define BM_ChipLabResponse_ReasonLength_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal310_acc_bytes;\
	UINT bmlocal311_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal310_acc_bytes = 8;\
	bmlocal311_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal310_acc_bytes );\
	out_bitoff += bmlocal311_acc_bits;\
}

#define BM_ChipLabResponse_ReasonLength_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal312_tmp_bitoff;\
	BM_ChipLabResponse_ReasonLength_GET_POS( base_ptr, out_ptr, bmlocal312_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal312_tmp_bitoff);\
}

#define BM_ChipLabResponse_ReasonLength_POS_ALIGNED 8

// Alignment of ChipLabResponse_ReasonLength: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_ChipLabResponse_ReasonLength_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_ReasonLength_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal313_my_ptr;\
	UINT bmlocal314_my_bitoff;\
	BM_ChipLabResponse_ReasonLength_GET_POS( base_ptr, bmlocal313_my_ptr, bmlocal314_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal313_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal313_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal313_my_ptr, bmlocal314_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_ChipLabResponse_ReasonLength_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT32 bmlocal315_tmp_var;
	BM_ChipLabResponse_ReasonLength_GET( base_ptr, bmlocal315_tmp_var );
	return bmlocal315_tmp_var;
}

#define BM_ChipLabResponse_ReasonLength_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal316_my_ptr;\
	UINT bmlocal317_my_bitoff;\
	BM_ChipLabResponse_ReasonLength_GET_POS( base_ptr, bmlocal316_my_ptr, bmlocal317_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal316_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal316_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal316_my_ptr, bmlocal317_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// ChipLabResponse_ReasonLength: IS_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_ReasonLength: SET_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_ReasonLength: IS_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_ReasonLength: SET_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_ReasonLength: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChipLabResponse_ReasonLength: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChipLabResponse_ReasonLength_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal318_out_val;\
	BM_ChipLabResponse_ReasonLength_GET( base_ptr, bmlocal318_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "ReasonLength", 32, (UINT)(bmlocal318_out_val), "%d", 1);\
}

#define BM_ChipLabResponse_ReasonLength_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_ReasonLength_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_ChipLabResponse_ReasonLength_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal319_my_ptr;\
	UINT bmlocal320_my_bitoff;\
	BM_ChipLabResponse_ReasonLength_GET_POS( base_ptr, bmlocal319_my_ptr, bmlocal320_my_bitoff );\
	(*((UINT32*)bmlocal319_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal320_my_bitoff );\
}

// ChipLabResponse_ReasonLength: Validation accessors are not defined because validation condition was not specified.
#define BM_ChipLabResponse_ReasonLength_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal321_tmp_bits;\
	BM_ChipLabResponse_ReasonLength_GET_SIZE( base_ptr, out_bytes, bmlocal321_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal321_tmp_bits );\
}

#define BM_ChipLabResponse_ReasonLength_BYTES_SIZE 4

#define BM_ChipLabResponse_Reason_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal324_acc_bytes;\
	UINT bmlocal325_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal324_acc_bytes = 12;\
	bmlocal325_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal324_acc_bytes );\
	out_bitoff += bmlocal325_acc_bits;\
}

#define BM_ChipLabResponse_Reason_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal326_tmp_bitoff;\
	BM_ChipLabResponse_Reason_GET_POS( base_ptr, out_ptr, bmlocal326_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal326_tmp_bitoff);\
}

#define BM_ChipLabResponse_Reason_POS_ALIGNED 12

// ARRAY: ChipLabResponse_Reason
#define BM_ChipLabResponse_Reason_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 128;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Reason_GET_DIMENSION_ELEMENT_COUNT( base_ptr, index, out_element_count )\
{\
	/*lint --e{*} */\
	switch( index )\
	{\
		case (0):\
		out_element_count = 128;\
		break;\
		default:\
		out_element_count = 0;\
		break;\
	}\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Reason_GET_ELEMENT_POS( base_ptr, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal327_out_ptr;\
	UINT bmlocal328_out_bitoff;\
	UINT bmlocal329_element_size_bytes;\
	UINT bmlocal330_element_size_bits;\
	BM_ChipLabResponse_Reason_GET_POS( base_ptr, bmlocal327_out_ptr, bmlocal328_out_bitoff );\
	bmlocal329_element_size_bytes = 1;\
	bmlocal330_element_size_bits = 0;\
	out_ptr = BMI_NUMBER_TO_PTR_CAST( BMI_PTR_TO_NUMERIC_CAST(bmlocal327_out_ptr) + (idx0) * bmlocal329_element_size_bytes );\
	out_bitoff = bmlocal328_out_bitoff;\
	BMI_UNUSED_VAR( bmlocal330_element_size_bits );\
}

// COMPOSITE: Full name: 'ChipLabResponse_Reason' Type: 'BufferString', Inner, Non-instance, No bitoff root
#define BM_ChipLabResponse_Reason_BufferByte_GET_POS( base_ptr, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal331_parent_out_ptr;\
	BM_ChipLabResponse_Reason_GET_ELEMENT_POS( base_ptr, idx0, bmlocal331_parent_out_ptr, out_bitoff );\
	out_ptr = bmlocal331_parent_out_ptr;\
}

#define BM_ChipLabResponse_Reason_BufferByte_GET_POS_ALIGNED( base_ptr, idx0, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal332_tmp_bitoff;\
	BM_ChipLabResponse_Reason_BufferByte_GET_POS( base_ptr, idx0, out_ptr, bmlocal332_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal332_tmp_bitoff);\
}

// Alignment of ChipLabResponse_Reason_BufferByte: accumulated=(0,0, ABA=1), parent.base=(0,0, ABA=1)
#define BM_ChipLabResponse_Reason_BufferByte_GET_SIZE( base_ptr, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Reason_BufferByte_GET( base_ptr, idx0, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal333_my_ptr;\
	UINT bmlocal334_my_bitoff;\
	BM_ChipLabResponse_Reason_BufferByte_GET_POS( base_ptr, idx0, bmlocal333_my_ptr, bmlocal334_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT8)BMI_32BIT_EXTRACT( (BMI_GET_8BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal333_my_ptr)) ), 0, 8, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT8)BMI_32BIT_EXTRACT( (BMI_GET_8BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal333_my_ptr)) ), 0, 8, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal333_my_ptr, bmlocal334_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
	}\
}

BMI_INLINE UINT8 BM_INLINE_ChipLabResponse_Reason_BufferByte_GET(PVOID base_ptr, UINT idx0)
{
	/*lint --e{*} */
	UINT8 bmlocal335_tmp_var;
	BM_ChipLabResponse_Reason_BufferByte_GET( base_ptr, idx0, bmlocal335_tmp_var );
	return bmlocal335_tmp_var;
}

#define BM_ChipLabResponse_Reason_BufferByte_SET( base_ptr, idx0, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal336_my_ptr;\
	UINT bmlocal337_my_bitoff;\
	BM_ChipLabResponse_Reason_BufferByte_GET_POS( base_ptr, idx0, bmlocal336_my_ptr, bmlocal337_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_8BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal336_my_ptr) ), (in_val), 0, 0, 8, UINT8 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_8BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal336_my_ptr) ), (in_val), 0, 0, 8, UINT8 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal336_my_ptr, bmlocal337_my_bitoff, 8, in_val, 0xFFFFFFFF );\
	}\
}

// ChipLabResponse_Reason_BufferByte: IS_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Reason_BufferByte: SET_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Reason_BufferByte: IS_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Reason_BufferByte: SET_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Reason_BufferByte: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChipLabResponse_Reason_BufferByte: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChipLabResponse_Reason_BufferByte_DUMP_DEPTH( base_ptr, idx0, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal338_out_val;\
	BM_ChipLabResponse_Reason_BufferByte_GET( base_ptr, idx0, bmlocal338_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "BufferByte", 8, (UINT)(bmlocal338_out_val), "%d", 1);\
}

#define BM_ChipLabResponse_Reason_BufferByte_DUMP( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Reason_BufferByte_DUMP_DEPTH( base_ptr, idx0, 0 );\
}

#define BM_ChipLabResponse_Reason_BufferByte_INCREMENT( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	PVOID bmlocal339_my_ptr;\
	UINT bmlocal340_my_bitoff;\
	BM_ChipLabResponse_Reason_BufferByte_GET_POS( base_ptr, idx0, bmlocal339_my_ptr, bmlocal340_my_bitoff );\
	(*((UINT8*)bmlocal339_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal340_my_bitoff );\
}

// ChipLabResponse_Reason_BufferByte: Validation accessors are not defined because validation condition was not specified.
#define BM_ChipLabResponse_Reason_BufferByte_GET_BYTES_SIZE( base_ptr, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal341_tmp_bits;\
	BM_ChipLabResponse_Reason_BufferByte_GET_SIZE( base_ptr, idx0, out_bytes, bmlocal341_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal341_tmp_bits );\
}

#define BM_ChipLabResponse_Reason_BufferByte_BYTES_SIZE 1

#define BM_ChipLabResponse_Reason_GET_CELL_SIZE( base_ptr, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Reason_GET_BYTES_CELL_SIZE( base_ptr, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal344_tmp_bits;\
	BM_ChipLabResponse_Reason_GET_CELL_SIZE( base_ptr, idx0, out_bytes, bmlocal344_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal344_tmp_bits );\
}

#define BM_ChipLabResponse_Reason_BYTES_CELL_SIZE 1

#define BM_ChipLabResponse_Reason_DUMP_DEPTH_IDX( base_ptr, idx0, depth )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Reason_BufferByte_DUMP_DEPTH( base_ptr, idx0, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Reason_DUMP_IDX( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Reason_DUMP_DEPTH_IDX( base_ptr, idx0, 0 );\
}

#define BM_ChipLabResponse_Reason_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT bmlocal345_dim_size0;\
	UINT bmlocal346_idx0;\
	bmlocal345_dim_size0 = 128;\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Reason", 1);\
	for( bmlocal346_idx0=0; bmlocal346_idx0<bmlocal345_dim_size0; bmlocal346_idx0++ )\
	{\
		BMI_FORMAT_NONVALUE_DUMP((depth + 1), "(", 0);\
		/*lint -e(571) */\
		BMI_FORMAT_DUMP(0, "", 32, (UINT)(bmlocal346_idx0), "%d", 0);\
		BMI_FORMAT_NONVALUE_DUMP(0, ")", 1);\
		BM_ChipLabResponse_Reason_DUMP_DEPTH_IDX( base_ptr, bmlocal346_idx0, depth );\
	}\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Reason_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Reason_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_ChipLabResponse_Reason_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal347_tmp_bits;\
	BM_ChipLabResponse_Reason_GET_SIZE( base_ptr, out_bytes, bmlocal347_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal347_tmp_bits );\
}

#define BM_ChipLabResponse_Reason_BYTES_SIZE 128

#define BM_ChipLabResponse_Args_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal348_tmp_bytes = 0;\
	UINT bmlocal349_tmp_bits = 0;\
	UINT bmlocal350_acc_bytes;\
	UINT bmlocal351_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal350_acc_bytes = 12;\
	bmlocal351_acc_bits = 0;\
	BM_ChipLabResponse_Reason_GET_SIZE( base_ptr, bmlocal348_tmp_bytes, bmlocal349_tmp_bits );\
	bmlocal350_acc_bytes += bmlocal348_tmp_bytes;\
	bmlocal351_acc_bits += bmlocal349_tmp_bits;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal350_acc_bytes );\
	out_bitoff += bmlocal351_acc_bits;\
}

#define BM_ChipLabResponse_Args_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal352_tmp_bitoff;\
	BM_ChipLabResponse_Args_GET_POS( base_ptr, out_ptr, bmlocal352_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal352_tmp_bitoff);\
}

#define BM_ChipLabResponse_Args_POS_ALIGNED 140

// ARRAY: ChipLabResponse_Args
#define BM_ChipLabResponse_Args_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 12;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Args_GET_DIMENSION_ELEMENT_COUNT( base_ptr, index, out_element_count )\
{\
	/*lint --e{*} */\
	switch( index )\
	{\
		case (0):\
		out_element_count = 3;\
		break;\
		default:\
		out_element_count = 0;\
		break;\
	}\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Args_GET_ELEMENT_POS( base_ptr, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal353_out_ptr;\
	UINT bmlocal354_out_bitoff;\
	UINT bmlocal355_element_size_bytes;\
	UINT bmlocal356_element_size_bits;\
	BM_ChipLabResponse_Args_GET_POS( base_ptr, bmlocal353_out_ptr, bmlocal354_out_bitoff );\
	bmlocal355_element_size_bytes = 4;\
	bmlocal356_element_size_bits = 0;\
	out_ptr = BMI_NUMBER_TO_PTR_CAST( BMI_PTR_TO_NUMERIC_CAST(bmlocal353_out_ptr) + (idx0) * bmlocal355_element_size_bytes );\
	out_bitoff = bmlocal354_out_bitoff;\
	BMI_UNUSED_VAR( bmlocal356_element_size_bits );\
}

// COMPOSITE: Full name: 'ChipLabResponse_Args' Type: 'BufferUint32', Inner, Non-instance, No bitoff root
#define BM_ChipLabResponse_Args_Entry_GET_POS( base_ptr, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal357_parent_out_ptr;\
	BM_ChipLabResponse_Args_GET_ELEMENT_POS( base_ptr, idx0, bmlocal357_parent_out_ptr, out_bitoff );\
	out_ptr = bmlocal357_parent_out_ptr;\
}

#define BM_ChipLabResponse_Args_Entry_GET_POS_ALIGNED( base_ptr, idx0, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal358_tmp_bitoff;\
	BM_ChipLabResponse_Args_Entry_GET_POS( base_ptr, idx0, out_ptr, bmlocal358_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal358_tmp_bitoff);\
}

// Alignment of ChipLabResponse_Args_Entry: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_ChipLabResponse_Args_Entry_GET_SIZE( base_ptr, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Args_Entry_GET( base_ptr, idx0, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal359_my_ptr;\
	UINT bmlocal360_my_bitoff;\
	BM_ChipLabResponse_Args_Entry_GET_POS( base_ptr, idx0, bmlocal359_my_ptr, bmlocal360_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal359_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal359_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal359_my_ptr, bmlocal360_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_ChipLabResponse_Args_Entry_GET(PVOID base_ptr, UINT idx0)
{
	/*lint --e{*} */
	UINT32 bmlocal361_tmp_var;
	BM_ChipLabResponse_Args_Entry_GET( base_ptr, idx0, bmlocal361_tmp_var );
	return bmlocal361_tmp_var;
}

#define BM_ChipLabResponse_Args_Entry_SET( base_ptr, idx0, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal362_my_ptr;\
	UINT bmlocal363_my_bitoff;\
	BM_ChipLabResponse_Args_Entry_GET_POS( base_ptr, idx0, bmlocal362_my_ptr, bmlocal363_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal362_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal362_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal362_my_ptr, bmlocal363_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// ChipLabResponse_Args_Entry: IS_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Args_Entry: SET_DEFAULT accessor is not defined because no default value was specified.
// ChipLabResponse_Args_Entry: IS_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Args_Entry: SET_RESET accessor is not defined because no reset value was specified.
// ChipLabResponse_Args_Entry: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChipLabResponse_Args_Entry: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChipLabResponse_Args_Entry_DUMP_DEPTH( base_ptr, idx0, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal364_out_val;\
	BM_ChipLabResponse_Args_Entry_GET( base_ptr, idx0, bmlocal364_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Entry", 32, (UINT)(bmlocal364_out_val), "%d", 1);\
}

#define BM_ChipLabResponse_Args_Entry_DUMP( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Args_Entry_DUMP_DEPTH( base_ptr, idx0, 0 );\
}

#define BM_ChipLabResponse_Args_Entry_INCREMENT( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	PVOID bmlocal365_my_ptr;\
	UINT bmlocal366_my_bitoff;\
	BM_ChipLabResponse_Args_Entry_GET_POS( base_ptr, idx0, bmlocal365_my_ptr, bmlocal366_my_bitoff );\
	(*((UINT32*)bmlocal365_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal366_my_bitoff );\
}

// ChipLabResponse_Args_Entry: Validation accessors are not defined because validation condition was not specified.
#define BM_ChipLabResponse_Args_Entry_GET_BYTES_SIZE( base_ptr, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal367_tmp_bits;\
	BM_ChipLabResponse_Args_Entry_GET_SIZE( base_ptr, idx0, out_bytes, bmlocal367_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal367_tmp_bits );\
}

#define BM_ChipLabResponse_Args_Entry_BYTES_SIZE 4

#define BM_ChipLabResponse_Args_GET_CELL_SIZE( base_ptr, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Args_GET_BYTES_CELL_SIZE( base_ptr, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal370_tmp_bits;\
	BM_ChipLabResponse_Args_GET_CELL_SIZE( base_ptr, idx0, out_bytes, bmlocal370_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal370_tmp_bits );\
}

#define BM_ChipLabResponse_Args_BYTES_CELL_SIZE 4

#define BM_ChipLabResponse_Args_DUMP_DEPTH_IDX( base_ptr, idx0, depth )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Args_Entry_DUMP_DEPTH( base_ptr, idx0, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChipLabResponse_Args_DUMP_IDX( base_ptr, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Args_DUMP_DEPTH_IDX( base_ptr, idx0, 0 );\
}

#define BM_ChipLabResponse_Args_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT bmlocal371_dim_size0;\
	UINT bmlocal372_idx0;\
	bmlocal371_dim_size0 = 3;\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Args", 1);\
	for( bmlocal372_idx0=0; bmlocal372_idx0<bmlocal371_dim_size0; bmlocal372_idx0++ )\
	{\
		BMI_FORMAT_NONVALUE_DUMP((depth + 1), "(", 0);\
		/*lint -e(571) */\
		BMI_FORMAT_DUMP(0, "", 32, (UINT)(bmlocal372_idx0), "%d", 0);\
		BMI_FORMAT_NONVALUE_DUMP(0, ")", 1);\
		BM_ChipLabResponse_Args_DUMP_DEPTH_IDX( base_ptr, bmlocal372_idx0, depth );\
	}\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_Args_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_Args_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_ChipLabResponse_Args_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal373_tmp_bits;\
	BM_ChipLabResponse_Args_GET_SIZE( base_ptr, out_bytes, bmlocal373_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal373_tmp_bits );\
}

#define BM_ChipLabResponse_Args_BYTES_SIZE 12

#define BM_ChipLabResponse_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	UINT bmlocal374_tmp_bytes = 0;\
	UINT bmlocal375_tmp_bits = 0;\
	out_bytes = 12;\
	out_bits = 0;\
	BM_ChipLabResponse_Reason_GET_SIZE( base_ptr, bmlocal374_tmp_bytes, bmlocal375_tmp_bits );\
	out_bytes += bmlocal374_tmp_bytes;\
	out_bits += bmlocal375_tmp_bits;\
	BM_ChipLabResponse_Args_GET_SIZE( base_ptr, bmlocal374_tmp_bytes, bmlocal375_tmp_bits );\
	out_bytes += bmlocal374_tmp_bytes;\
	out_bits += bmlocal375_tmp_bits;\
}

#define BM_ChipLabResponse_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal376_tmp_bits;\
	BM_ChipLabResponse_GET_SIZE( base_ptr, out_bytes, bmlocal376_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal376_tmp_bits );\
}

#define BM_ChipLabResponse_BYTES_SIZE 152

#define BM_ChipLabResponse_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "ChipLabResponse", 1);\
	BM_ChipLabResponse_Ack_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_ChipLabResponse_Code_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_ChipLabResponse_ReasonLength_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_ChipLabResponse_Reason_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_ChipLabResponse_Args_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_ChipLabResponse_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_ChipLabResponse_DUMP_DEPTH( base_ptr, 0 );\
}


typedef enum
{
	LTA_RESPONSE_SUCCESS,
	LTA_RESPONSE_PAYLOAD_SIZE_MISMATCH,
	LTA_RESPONSE_INVALID_STATE,
	LTA_RESPONSE_INVALID_ARG,
	LTA_RESPONSE_OUTOFMEM,
	LTA_RESPONSE_DATA_LOCKED
} Lta_ResponseCode;

typedef enum
{
	LTA_RESPONSE_NACK = 0,
	LTA_RESPONSE_ACK = 1
} Lta_ResponseSuccess;

/*lint --flb */

#endif /* _BITMAN_BMCHIPLABINTERFACE_H_ */

