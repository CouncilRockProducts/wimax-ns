/*****************************************************************************
 * Automatically generated by Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0) - DO NOT EDIT!
 * Generated at 11/19/2009 12:56:07 AM
 *
 * Project : Ofer
 * Module  : Simple types
 * Author  : Leah Miron
 * Date    : January 17th 2005
 * Purpose : Define composite wrappers for C simple types
 *****************************************************************************/

#if !defined(_BITMAN_BASICBITMANTYPES_H_)
#define _BITMAN_BASICBITMANTYPES_H_


/*lint ++flb */
// Include the Bitman common header file
#include "BitmanCommon.h"

// Include headers generated from XMLs (the source is both XMLs and the command-line)

// Include user C header files
#include "Pal_General.h"


// Bitman version Accessor...
#ifndef BM_BITMAN_VERSION
#define BM_BITMAN_VERSION 	"Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0)"
#endif 

// Definitions

typedef UINT8 Uint32[4];

// Generating two structs for top-level composite 'Uint32', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Uint32'

typedef UINT8 Uint16[2];

// Generating two structs for top-level composite 'Uint16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Uint16'

typedef UINT8 Uint8[1];

// Generating two structs for top-level composite 'Uint8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Uint8'

typedef UINT8 Int8[1];

// Generating two structs for top-level composite 'Int8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Int8'

typedef UINT8 Int16[2];

// Generating two structs for top-level composite 'Int16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Int16'

typedef UINT8 Char[1];

// Generating two structs for top-level composite 'Char', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Char'

typedef UINT8 Flag[1];

// Generating two structs for top-level composite 'Flag', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'Flag'

typedef UINT8 BigUint32[4];

// Generating two structs for top-level composite 'BigUint32', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_BigUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_BigUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_BigUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_BigUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigUint32'

typedef UINT8 BigUint16[2];

// Generating two structs for top-level composite 'BigUint16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_BigUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_BigUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_BigUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_BigUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigUint16'

typedef UINT8 BigUint8[1];

// Generating two structs for top-level composite 'BigUint8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_BigUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_BigUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_BigUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_BigUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigUint8'

typedef UINT8 BigInt16[2];

// Generating two structs for top-level composite 'BigInt16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_BigInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_BigInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_BigInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_BigInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigInt16'

typedef UINT8 BigInt8[1];

// Generating two structs for top-level composite 'BigInt8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_BigInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_BigInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_BigInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_BigInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigInt8'

typedef UINT8 BigChar[1];

// Generating two structs for top-level composite 'BigChar', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_BigChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_BigChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_BigChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_BigChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigChar'

typedef UINT8 BigFlag[1];

// Generating two structs for top-level composite 'BigFlag', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_BigFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_BigFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_BigFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_BigFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'BigFlag'

typedef UINT8 LittleUint32[4];

// Generating two structs for top-level composite 'LittleUint32', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_LittleUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_BigEndianness_LittleUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_LittleUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_LittleEndianness_LittleUint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleUint32'

typedef UINT8 LittleUint16[2];

// Generating two structs for top-level composite 'LittleUint16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_LittleUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_BigEndianness_LittleUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_LittleUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_LittleEndianness_LittleUint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleUint16'

typedef UINT8 LittleUint8[1];

// Generating two structs for top-level composite 'LittleUint8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_LittleUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_BigEndianness_LittleUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_LittleUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_LittleEndianness_LittleUint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleUint8'

typedef UINT8 LittleInt16[2];

// Generating two structs for top-level composite 'LittleInt16', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_LittleInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_BigEndianness_LittleInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_LittleInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_LittleEndianness_LittleInt16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleInt16'

typedef UINT8 LittleInt8[1];

// Generating two structs for top-level composite 'LittleInt8', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_LittleInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_BigEndianness_LittleInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_LittleInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_LittleEndianness_LittleInt8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleInt8'

typedef UINT8 LittleChar[1];

// Generating two structs for top-level composite 'LittleChar', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_LittleChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_BigEndianness_LittleChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_LittleChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_LittleEndianness_LittleChar;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleChar'

typedef UINT8 LittleFlag[1];

// Generating two structs for top-level composite 'LittleFlag', because it has Neutral endianness.
/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_LittleFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_BigEndianness_LittleFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_LittleFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_LittleEndianness_LittleFlag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// Not generating code for top-level composite 'LittleFlag'

typedef UINT8 Little_Uint32[4];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_Little_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _value;
} BMS_Little_Uint32;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Uint32' Type: 'Little_Uint32', Top-level, Non-instance, No bitoff root
#define BM_Little_Uint32_value_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
}

#define BM_Little_Uint32_value_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal0_tmp_bitoff;\
	BM_Little_Uint32_value_GET_POS( base_ptr, out_ptr, bmlocal0_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal0_tmp_bitoff);\
}

#define BM_Little_Uint32_value_POS_ALIGNED 0

// Alignment of Little_Uint32_value: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_Little_Uint32_value_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_Little_Uint32_value_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal1_my_ptr;\
	UINT bmlocal2_my_bitoff;\
	BM_Little_Uint32_value_GET_POS( base_ptr, bmlocal1_my_ptr, bmlocal2_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal1_my_ptr)) ), 0, 32, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT32)BMI_32BIT_EXTRACT( (BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal1_my_ptr)) ), 0, 32, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal1_my_ptr, bmlocal2_my_bitoff, 32, UINT32, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT32 BM_INLINE_Little_Uint32_value_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT32 bmlocal3_tmp_var;
	BM_Little_Uint32_value_GET( base_ptr, bmlocal3_tmp_var );
	return bmlocal3_tmp_var;
}

#define BM_Little_Uint32_value_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal4_my_ptr;\
	UINT bmlocal5_my_bitoff;\
	BM_Little_Uint32_value_GET_POS( base_ptr, bmlocal4_my_ptr, bmlocal5_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal4_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_32BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal4_my_ptr) ), (in_val), 0, 0, 32, UINT32 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal4_my_ptr, bmlocal5_my_bitoff, 32, in_val, 0x00000000 );\
	}\
}

// Little_Uint32_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint32_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint32_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Uint32_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Uint32_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Uint32_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Uint32_value_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal6_out_val;\
	BM_Little_Uint32_value_GET( base_ptr, bmlocal6_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 32, (UINT)(bmlocal6_out_val), "%d", 1);\
}

#define BM_Little_Uint32_value_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_Little_Uint32_value_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_Little_Uint32_value_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal7_my_ptr;\
	UINT bmlocal8_my_bitoff;\
	BM_Little_Uint32_value_GET_POS( base_ptr, bmlocal7_my_ptr, bmlocal8_my_bitoff );\
	(*((UINT32*)bmlocal7_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal8_my_bitoff );\
}

// Little_Uint32_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Uint32_value_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal9_tmp_bits;\
	BM_Little_Uint32_value_GET_SIZE( base_ptr, out_bytes, bmlocal9_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal9_tmp_bits );\
}

#define BM_Little_Uint32_value_BYTES_SIZE 4

#define BM_Little_Uint32_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_Little_Uint32_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal12_tmp_bits;\
	BM_Little_Uint32_GET_SIZE( base_ptr, out_bytes, bmlocal12_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal12_tmp_bits );\
}

#define BM_Little_Uint32_BYTES_SIZE 4

BMI_INLINE UINT BM_INLINE_Little_Uint32_GET_SIZE()
{
	/*lint --e{*} */
	return 4;
}

#define BM_Little_Uint32_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Uint32", 1);\
	BM_Little_Uint32_value_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_Little_Uint32_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_Little_Uint32_DUMP_DEPTH( base_ptr, 0 );\
}


typedef UINT8 Little_Uint16[2];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_Little_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _value : 16;
} BMS_Little_Uint16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Uint16' Type: 'Little_Uint16', Top-level, Non-instance, Including bitoff root
#define BM_Little_Uint16_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Uint16_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Uint16_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint16_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal13_my_ptr;\
	UINT bmlocal14_my_bitoff;\
	BM_Little_Uint16_value_GET_POS( base_ptr, base_bitoff, bmlocal13_my_ptr, bmlocal14_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal13_my_ptr, bmlocal14_my_bitoff, 16, UINT16, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT16 BM_INLINE_Little_Uint16_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT16 bmlocal15_tmp_var;
	BM_Little_Uint16_value_GET( base_ptr, base_bitoff, bmlocal15_tmp_var );
	return bmlocal15_tmp_var;
}

#define BM_Little_Uint16_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal16_my_ptr;\
	UINT bmlocal17_my_bitoff;\
	BM_Little_Uint16_value_GET_POS( base_ptr, base_bitoff, bmlocal16_my_ptr, bmlocal17_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal16_my_ptr, bmlocal17_my_bitoff, 16, in_val, 0xFFFFFFFF );\
}

// Little_Uint16_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint16_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint16_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Uint16_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Uint16_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Uint16_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Uint16_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal18_out_val;\
	BM_Little_Uint16_value_GET( base_ptr, base_bitoff, bmlocal18_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 16, (UINT)(bmlocal18_out_val), "%d", 1);\
}

#define BM_Little_Uint16_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Uint16_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Uint16_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal19_val;\
	BM_Little_Uint16_value_GET( base_ptr, base_bitoff, bmlocal19_val );\
	(bmlocal19_val)++;\
	BM_Little_Uint16_value_SET( base_ptr, base_bitoff, bmlocal19_val );\
}

// Little_Uint16_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Uint16_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal20_tmp_bits;\
	BM_Little_Uint16_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal20_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal20_tmp_bits );\
}

#define BM_Little_Uint16_value_BYTES_SIZE 2

#define BM_Little_Uint16_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint16_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal23_tmp_bits;\
	BM_Little_Uint16_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal23_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal23_tmp_bits );\
}

#define BM_Little_Uint16_BYTES_SIZE 2

BMI_INLINE UINT BM_INLINE_Little_Uint16_GET_SIZE()
{
	/*lint --e{*} */
	return 2;
}

#define BM_Little_Uint16_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Uint16", 1);\
	BM_Little_Uint16_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint16_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Uint16_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


typedef UINT8 Little_Uint8[1];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_Little_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 8;
} BMS_Little_Uint8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Uint8' Type: 'Little_Uint8', Top-level, Non-instance, Including bitoff root
#define BM_Little_Uint8_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Uint8_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Uint8_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint8_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal24_my_ptr;\
	UINT bmlocal25_my_bitoff;\
	BM_Little_Uint8_value_GET_POS( base_ptr, base_bitoff, bmlocal24_my_ptr, bmlocal25_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal24_my_ptr, bmlocal25_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_Little_Uint8_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT8 bmlocal26_tmp_var;
	BM_Little_Uint8_value_GET( base_ptr, base_bitoff, bmlocal26_tmp_var );
	return bmlocal26_tmp_var;
}

#define BM_Little_Uint8_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal27_my_ptr;\
	UINT bmlocal28_my_bitoff;\
	BM_Little_Uint8_value_GET_POS( base_ptr, base_bitoff, bmlocal27_my_ptr, bmlocal28_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal27_my_ptr, bmlocal28_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// Little_Uint8_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint8_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Uint8_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Uint8_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Uint8_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Uint8_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Uint8_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal29_out_val;\
	BM_Little_Uint8_value_GET( base_ptr, base_bitoff, bmlocal29_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 8, (UINT)(bmlocal29_out_val), "%d", 1);\
}

#define BM_Little_Uint8_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Uint8_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Uint8_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal30_val;\
	BM_Little_Uint8_value_GET( base_ptr, base_bitoff, bmlocal30_val );\
	(bmlocal30_val)++;\
	BM_Little_Uint8_value_SET( base_ptr, base_bitoff, bmlocal30_val );\
}

// Little_Uint8_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Uint8_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal31_tmp_bits;\
	BM_Little_Uint8_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal31_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal31_tmp_bits );\
}

#define BM_Little_Uint8_value_BYTES_SIZE 1

#define BM_Little_Uint8_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint8_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal34_tmp_bits;\
	BM_Little_Uint8_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal34_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal34_tmp_bits );\
}

#define BM_Little_Uint8_BYTES_SIZE 1

BMI_INLINE UINT BM_INLINE_Little_Uint8_GET_SIZE()
{
	/*lint --e{*} */
	return 1;
}

#define BM_Little_Uint8_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Uint8", 1);\
	BM_Little_Uint8_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Uint8_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Uint8_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


typedef UINT8 Little_Int16[2];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_Little_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT16 _value : 16;
} BMS_Little_Int16;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Int16' Type: 'Little_Int16', Top-level, Non-instance, Including bitoff root
#define BM_Little_Int16_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Int16_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Int16_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int16_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal35_my_ptr;\
	UINT bmlocal36_my_bitoff;\
	BM_Little_Int16_value_GET_POS( base_ptr, base_bitoff, bmlocal35_my_ptr, bmlocal36_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal35_my_ptr, bmlocal36_my_bitoff, 16, INT16, out_val, 0xFFFFFFFF );\
}

BMI_INLINE INT16 BM_INLINE_Little_Int16_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	INT16 bmlocal37_tmp_var;
	BM_Little_Int16_value_GET( base_ptr, base_bitoff, bmlocal37_tmp_var );
	return bmlocal37_tmp_var;
}

#define BM_Little_Int16_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal38_my_ptr;\
	UINT bmlocal39_my_bitoff;\
	BM_Little_Int16_value_GET_POS( base_ptr, base_bitoff, bmlocal38_my_ptr, bmlocal39_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal38_my_ptr, bmlocal39_my_bitoff, 16, in_val, 0xFFFFFFFF );\
}

// Little_Int16_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Int16_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Int16_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Int16_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Int16_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Int16_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Int16_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	INT16 bmlocal40_out_val;\
	BM_Little_Int16_value_GET( base_ptr, base_bitoff, bmlocal40_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 16, (UINT)(bmlocal40_out_val), "%d", 1);\
}

#define BM_Little_Int16_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Int16_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Int16_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	INT16 bmlocal41_val;\
	BM_Little_Int16_value_GET( base_ptr, base_bitoff, bmlocal41_val );\
	(bmlocal41_val)++;\
	BM_Little_Int16_value_SET( base_ptr, base_bitoff, bmlocal41_val );\
}

// Little_Int16_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Int16_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal42_tmp_bits;\
	BM_Little_Int16_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal42_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal42_tmp_bits );\
}

#define BM_Little_Int16_value_BYTES_SIZE 2

#define BM_Little_Int16_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int16_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal45_tmp_bits;\
	BM_Little_Int16_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal45_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal45_tmp_bits );\
}

#define BM_Little_Int16_BYTES_SIZE 2

BMI_INLINE UINT BM_INLINE_Little_Int16_GET_SIZE()
{
	/*lint --e{*} */
	return 2;
}

#define BM_Little_Int16_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Int16", 1);\
	BM_Little_Int16_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int16_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Int16_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


typedef UINT8 Little_Int8[1];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_Little_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	INT8 _value : 8;
} BMS_Little_Int8;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Int8' Type: 'Little_Int8', Top-level, Non-instance, Including bitoff root
#define BM_Little_Int8_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Int8_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Int8_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int8_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal46_my_ptr;\
	UINT bmlocal47_my_bitoff;\
	BM_Little_Int8_value_GET_POS( base_ptr, base_bitoff, bmlocal46_my_ptr, bmlocal47_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal46_my_ptr, bmlocal47_my_bitoff, 8, INT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE INT8 BM_INLINE_Little_Int8_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	INT8 bmlocal48_tmp_var;
	BM_Little_Int8_value_GET( base_ptr, base_bitoff, bmlocal48_tmp_var );
	return bmlocal48_tmp_var;
}

#define BM_Little_Int8_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal49_my_ptr;\
	UINT bmlocal50_my_bitoff;\
	BM_Little_Int8_value_GET_POS( base_ptr, base_bitoff, bmlocal49_my_ptr, bmlocal50_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal49_my_ptr, bmlocal50_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// Little_Int8_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Int8_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Int8_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Int8_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Int8_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Int8_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Int8_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	INT8 bmlocal51_out_val;\
	BM_Little_Int8_value_GET( base_ptr, base_bitoff, bmlocal51_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 8, (UINT)(bmlocal51_out_val), "%d", 1);\
}

#define BM_Little_Int8_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Int8_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Int8_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	INT8 bmlocal52_val;\
	BM_Little_Int8_value_GET( base_ptr, base_bitoff, bmlocal52_val );\
	(bmlocal52_val)++;\
	BM_Little_Int8_value_SET( base_ptr, base_bitoff, bmlocal52_val );\
}

// Little_Int8_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Int8_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal53_tmp_bits;\
	BM_Little_Int8_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal53_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal53_tmp_bits );\
}

#define BM_Little_Int8_value_BYTES_SIZE 1

#define BM_Little_Int8_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int8_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal56_tmp_bits;\
	BM_Little_Int8_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal56_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal56_tmp_bits );\
}

#define BM_Little_Int8_BYTES_SIZE 1

BMI_INLINE UINT BM_INLINE_Little_Int8_GET_SIZE()
{
	/*lint --e{*} */
	return 1;
}

#define BM_Little_Int8_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Int8", 1);\
	BM_Little_Int8_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Int8_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Int8_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


typedef UINT8 Little_Char[1];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_Little_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	char _value : 8;
} BMS_Little_Char;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Char' Type: 'Little_Char', Top-level, Non-instance, Including bitoff root
#define BM_Little_Char_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Char_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Char_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Char_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal57_my_ptr;\
	UINT bmlocal58_my_bitoff;\
	BM_Little_Char_value_GET_POS( base_ptr, base_bitoff, bmlocal57_my_ptr, bmlocal58_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal57_my_ptr, bmlocal58_my_bitoff, 8, char, out_val, 0xFFFFFFFF );\
}

BMI_INLINE char BM_INLINE_Little_Char_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	char bmlocal59_tmp_var;
	BM_Little_Char_value_GET( base_ptr, base_bitoff, bmlocal59_tmp_var );
	return bmlocal59_tmp_var;
}

#define BM_Little_Char_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal60_my_ptr;\
	UINT bmlocal61_my_bitoff;\
	BM_Little_Char_value_GET_POS( base_ptr, base_bitoff, bmlocal60_my_ptr, bmlocal61_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal60_my_ptr, bmlocal61_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// Little_Char_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Char_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Char_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Char_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Char_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Char_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Char_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	char bmlocal62_out_val;\
	BM_Little_Char_value_GET( base_ptr, base_bitoff, bmlocal62_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 8, (UINT)(bmlocal62_out_val), "%d", 1);\
}

#define BM_Little_Char_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Char_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Char_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	char bmlocal63_val;\
	BM_Little_Char_value_GET( base_ptr, base_bitoff, bmlocal63_val );\
	(bmlocal63_val)++;\
	BM_Little_Char_value_SET( base_ptr, base_bitoff, bmlocal63_val );\
}

// Little_Char_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Char_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal64_tmp_bits;\
	BM_Little_Char_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal64_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal64_tmp_bits );\
}

#define BM_Little_Char_value_BYTES_SIZE 1

#define BM_Little_Char_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Char_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal67_tmp_bits;\
	BM_Little_Char_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal67_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal67_tmp_bits );\
}

#define BM_Little_Char_BYTES_SIZE 1

BMI_INLINE UINT BM_INLINE_Little_Char_GET_SIZE()
{
	/*lint --e{*} */
	return 1;
}

#define BM_Little_Char_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Char", 1);\
	BM_Little_Char_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Char_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Char_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


typedef UINT8 Little_Flag[1];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_Little_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _value : 1;
} BMS_Little_Flag;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'Little_Flag' Type: 'Little_Flag', Top-level, Non-instance, Including bitoff root
#define BM_Little_Flag_value_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of Little_Flag_value: accumulated=(Variable), parent.base=(Variable)
#define BM_Little_Flag_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 0;\
	out_bits = 1;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Flag_value_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal68_my_ptr;\
	UINT bmlocal69_my_bitoff;\
	BM_Little_Flag_value_GET_POS( base_ptr, base_bitoff, bmlocal68_my_ptr, bmlocal69_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal68_my_ptr, bmlocal69_my_bitoff, 1, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_Little_Flag_value_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT8 bmlocal70_tmp_var;
	BM_Little_Flag_value_GET( base_ptr, base_bitoff, bmlocal70_tmp_var );
	return bmlocal70_tmp_var;
}

#define BM_Little_Flag_value_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal71_my_ptr;\
	UINT bmlocal72_my_bitoff;\
	BM_Little_Flag_value_GET_POS( base_ptr, base_bitoff, bmlocal71_my_ptr, bmlocal72_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal71_my_ptr, bmlocal72_my_bitoff, 1, in_val, 0xFFFFFFFF );\
}

// Little_Flag_value: IS_DEFAULT accessor is not defined because no default value was specified.
// Little_Flag_value: SET_DEFAULT accessor is not defined because no default value was specified.
// Little_Flag_value: IS_RESET accessor is not defined because no reset value was specified.
// Little_Flag_value: SET_RESET accessor is not defined because no reset value was specified.
// Little_Flag_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// Little_Flag_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_Little_Flag_value_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal73_out_val;\
	BM_Little_Flag_value_GET( base_ptr, base_bitoff, bmlocal73_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 1, (UINT)(bmlocal73_out_val), "%d", 1);\
}

#define BM_Little_Flag_value_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Flag_value_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_Little_Flag_value_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal74_val;\
	BM_Little_Flag_value_GET( base_ptr, base_bitoff, bmlocal74_val );\
	(bmlocal74_val)++;\
	BM_Little_Flag_value_SET( base_ptr, base_bitoff, bmlocal74_val );\
}

// Little_Flag_value: Validation accessors are not defined because validation condition was not specified.
#define BM_Little_Flag_value_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal75_tmp_bits;\
	BM_Little_Flag_value_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal75_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal75_tmp_bits );\
}

#define BM_Little_Flag_value_BYTES_SIZE 1

#define BM_Little_Flag_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 0;\
	out_bits = 1;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Flag_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal78_tmp_bits;\
	BM_Little_Flag_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal78_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal78_tmp_bits );\
}

#define BM_Little_Flag_BYTES_SIZE 1

#define BM_Little_Flag_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Little_Flag", 1);\
	BM_Little_Flag_value_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_Little_Flag_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_Little_Flag_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


/*lint --flb */

#endif /* _BITMAN_BASICBITMANTYPES_H_ */

