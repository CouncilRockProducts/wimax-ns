/*****************************************************************************
 * Automatically generated by Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0) - DO NOT EDIT!
 * Generated at 3/23/2009 2:35:08 PM
 *
 * Project : Ofer
 * Module  : L3L4 interface
 * Author  : Roy Ramon And Anat Ganor
 * Date    : Oct 25th 2006
 * Purpose : Define the L3 L4 msgs
 *****************************************************************************/

#if !defined(_BITMAN_L4COMMON_H_)
#define _BITMAN_L4COMMON_H_


/*lint ++flb */
// Include the Bitman common header file
#include "BitmanCommon.h"

// Include headers generated from XMLs (the source is both XMLs and the command-line)
#include "BasicBitmanTypes.h"

// Include user C header files
#include <L3L4CommonDefines.h>


// Bitman version Accessor...
#ifndef BM_BITMAN_VERSION
#define BM_BITMAN_VERSION 	"Bitman2Base V4.2.5.0 (5.0) Bitman2 (exe) V4.2.5.0 (5.0)"
#endif 

// Definitions

typedef UINT8 L3L4CompleteHeader[12];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _Type : 16;
	UINT16 _Length : 16;
	UINT16 _Version : 16;
	UINT16 _Accessibility : 16;
	UINT16 _Status : 16;
	UINT16 _Reserved2 : 16;
} BMS_L3L4CompleteHeader;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT16 _Reserved2 : 16;
	UINT16 _Status : 16;
	UINT16 _Accessibility : 16;
	UINT16 _Version : 16;
	UINT16 _Length : 16;
	UINT16 _Type : 16;
} BMS_L3L4CompleteHeader;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'L3L4CompleteHeader' Type: 'L3L4CompleteHeader', Top-level, Non-instance, No bitoff root
#define BM_L3L4CompleteHeader_Type_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
}

#define BM_L3L4CompleteHeader_Type_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal79_tmp_bitoff;\
	BM_L3L4CompleteHeader_Type_GET_POS( base_ptr, out_ptr, bmlocal79_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal79_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Type_POS_ALIGNED 0

// Alignment of L3L4CompleteHeader_Type: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Type_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Type_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal80_my_ptr;\
	UINT bmlocal81_my_bitoff;\
	BM_L3L4CompleteHeader_Type_GET_POS( base_ptr, bmlocal80_my_ptr, bmlocal81_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal80_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal80_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal80_my_ptr, bmlocal81_my_bitoff, 16, UINT16, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Type_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal82_tmp_var;
	BM_L3L4CompleteHeader_Type_GET( base_ptr, bmlocal82_tmp_var );
	return bmlocal82_tmp_var;
}

#define BM_L3L4CompleteHeader_Type_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal83_my_ptr;\
	UINT bmlocal84_my_bitoff;\
	BM_L3L4CompleteHeader_Type_GET_POS( base_ptr, bmlocal83_my_ptr, bmlocal84_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal83_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal83_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal83_my_ptr, bmlocal84_my_bitoff, 16, in_val, 0x00000000 );\
	}\
}

// L3L4CompleteHeader_Type: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Type: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Type: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Type: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Type: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Type: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Type_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal85_out_val;\
	BM_L3L4CompleteHeader_Type_GET( base_ptr, bmlocal85_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Type", 16, (UINT)(bmlocal85_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Type_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Type_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Type_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal86_my_ptr;\
	UINT bmlocal87_my_bitoff;\
	BM_L3L4CompleteHeader_Type_GET_POS( base_ptr, bmlocal86_my_ptr, bmlocal87_my_bitoff );\
	(*((UINT16*)bmlocal86_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal87_my_bitoff );\
}

// L3L4CompleteHeader_Type: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Type_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal88_tmp_bits;\
	BM_L3L4CompleteHeader_Type_GET_SIZE( base_ptr, out_bytes, bmlocal88_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal88_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Type_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_Length_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal91_acc_bytes;\
	UINT bmlocal92_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal91_acc_bytes = 2;\
	bmlocal92_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal91_acc_bytes );\
	out_bitoff += bmlocal92_acc_bits;\
}

#define BM_L3L4CompleteHeader_Length_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal93_tmp_bitoff;\
	BM_L3L4CompleteHeader_Length_GET_POS( base_ptr, out_ptr, bmlocal93_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal93_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Length_POS_ALIGNED 2

// Alignment of L3L4CompleteHeader_Length: accumulated=(2,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Length_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Length_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal94_my_ptr;\
	UINT bmlocal95_my_bitoff;\
	BM_L3L4CompleteHeader_Length_GET_POS( base_ptr, bmlocal94_my_ptr, bmlocal95_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal94_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal94_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal94_my_ptr, bmlocal95_my_bitoff, 16, UINT16, out_val, 0x00000002 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Length_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal96_tmp_var;
	BM_L3L4CompleteHeader_Length_GET( base_ptr, bmlocal96_tmp_var );
	return bmlocal96_tmp_var;
}

#define BM_L3L4CompleteHeader_Length_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal97_my_ptr;\
	UINT bmlocal98_my_bitoff;\
	BM_L3L4CompleteHeader_Length_GET_POS( base_ptr, bmlocal97_my_ptr, bmlocal98_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal97_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal97_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal97_my_ptr, bmlocal98_my_bitoff, 16, in_val, 0x00000002 );\
	}\
}

// L3L4CompleteHeader_Length: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Length: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Length: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Length: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Length: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Length: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Length_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal99_out_val;\
	BM_L3L4CompleteHeader_Length_GET( base_ptr, bmlocal99_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Length", 16, (UINT)(bmlocal99_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Length_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Length_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Length_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal100_my_ptr;\
	UINT bmlocal101_my_bitoff;\
	BM_L3L4CompleteHeader_Length_GET_POS( base_ptr, bmlocal100_my_ptr, bmlocal101_my_bitoff );\
	(*((UINT16*)bmlocal100_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal101_my_bitoff );\
}

// L3L4CompleteHeader_Length: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Length_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal102_tmp_bits;\
	BM_L3L4CompleteHeader_Length_GET_SIZE( base_ptr, out_bytes, bmlocal102_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal102_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Length_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_Version_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal105_acc_bytes;\
	UINT bmlocal106_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal105_acc_bytes = 4;\
	bmlocal106_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal105_acc_bytes );\
	out_bitoff += bmlocal106_acc_bits;\
}

#define BM_L3L4CompleteHeader_Version_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal107_tmp_bitoff;\
	BM_L3L4CompleteHeader_Version_GET_POS( base_ptr, out_ptr, bmlocal107_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal107_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Version_POS_ALIGNED 4

// Alignment of L3L4CompleteHeader_Version: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Version_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Version_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal108_my_ptr;\
	UINT bmlocal109_my_bitoff;\
	BM_L3L4CompleteHeader_Version_GET_POS( base_ptr, bmlocal108_my_ptr, bmlocal109_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal108_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal108_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal108_my_ptr, bmlocal109_my_bitoff, 16, UINT16, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Version_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal110_tmp_var;
	BM_L3L4CompleteHeader_Version_GET( base_ptr, bmlocal110_tmp_var );
	return bmlocal110_tmp_var;
}

#define BM_L3L4CompleteHeader_Version_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal111_my_ptr;\
	UINT bmlocal112_my_bitoff;\
	BM_L3L4CompleteHeader_Version_GET_POS( base_ptr, bmlocal111_my_ptr, bmlocal112_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal111_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal111_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal111_my_ptr, bmlocal112_my_bitoff, 16, in_val, 0x00000000 );\
	}\
}

// L3L4CompleteHeader_Version: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Version: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Version: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Version: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Version: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Version: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Version_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal113_out_val;\
	BM_L3L4CompleteHeader_Version_GET( base_ptr, bmlocal113_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Version", 16, (UINT)(bmlocal113_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Version_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Version_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Version_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal114_my_ptr;\
	UINT bmlocal115_my_bitoff;\
	BM_L3L4CompleteHeader_Version_GET_POS( base_ptr, bmlocal114_my_ptr, bmlocal115_my_bitoff );\
	(*((UINT16*)bmlocal114_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal115_my_bitoff );\
}

// L3L4CompleteHeader_Version: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Version_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal116_tmp_bits;\
	BM_L3L4CompleteHeader_Version_GET_SIZE( base_ptr, out_bytes, bmlocal116_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal116_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Version_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_Accessibility_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal119_acc_bytes;\
	UINT bmlocal120_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal119_acc_bytes = 6;\
	bmlocal120_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal119_acc_bytes );\
	out_bitoff += bmlocal120_acc_bits;\
}

#define BM_L3L4CompleteHeader_Accessibility_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal121_tmp_bitoff;\
	BM_L3L4CompleteHeader_Accessibility_GET_POS( base_ptr, out_ptr, bmlocal121_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal121_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Accessibility_POS_ALIGNED 6

// Alignment of L3L4CompleteHeader_Accessibility: accumulated=(2,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Accessibility_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Accessibility_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal122_my_ptr;\
	UINT bmlocal123_my_bitoff;\
	BM_L3L4CompleteHeader_Accessibility_GET_POS( base_ptr, bmlocal122_my_ptr, bmlocal123_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal122_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal122_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal122_my_ptr, bmlocal123_my_bitoff, 16, UINT16, out_val, 0x00000002 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Accessibility_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal124_tmp_var;
	BM_L3L4CompleteHeader_Accessibility_GET( base_ptr, bmlocal124_tmp_var );
	return bmlocal124_tmp_var;
}

#define BM_L3L4CompleteHeader_Accessibility_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal125_my_ptr;\
	UINT bmlocal126_my_bitoff;\
	BM_L3L4CompleteHeader_Accessibility_GET_POS( base_ptr, bmlocal125_my_ptr, bmlocal126_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal125_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal125_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal125_my_ptr, bmlocal126_my_bitoff, 16, in_val, 0x00000002 );\
	}\
}

// L3L4CompleteHeader_Accessibility: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Accessibility: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Accessibility: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Accessibility: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Accessibility: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Accessibility: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Accessibility_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal127_out_val;\
	BM_L3L4CompleteHeader_Accessibility_GET( base_ptr, bmlocal127_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Accessibility", 16, (UINT)(bmlocal127_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Accessibility_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Accessibility_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Accessibility_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal128_my_ptr;\
	UINT bmlocal129_my_bitoff;\
	BM_L3L4CompleteHeader_Accessibility_GET_POS( base_ptr, bmlocal128_my_ptr, bmlocal129_my_bitoff );\
	(*((UINT16*)bmlocal128_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal129_my_bitoff );\
}

// L3L4CompleteHeader_Accessibility: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Accessibility_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal130_tmp_bits;\
	BM_L3L4CompleteHeader_Accessibility_GET_SIZE( base_ptr, out_bytes, bmlocal130_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal130_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Accessibility_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_Status_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal133_acc_bytes;\
	UINT bmlocal134_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal133_acc_bytes = 8;\
	bmlocal134_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal133_acc_bytes );\
	out_bitoff += bmlocal134_acc_bits;\
}

#define BM_L3L4CompleteHeader_Status_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal135_tmp_bitoff;\
	BM_L3L4CompleteHeader_Status_GET_POS( base_ptr, out_ptr, bmlocal135_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal135_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Status_POS_ALIGNED 8

// Alignment of L3L4CompleteHeader_Status: accumulated=(0,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Status_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Status_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal136_my_ptr;\
	UINT bmlocal137_my_bitoff;\
	BM_L3L4CompleteHeader_Status_GET_POS( base_ptr, bmlocal136_my_ptr, bmlocal137_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal136_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal136_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal136_my_ptr, bmlocal137_my_bitoff, 16, UINT16, out_val, 0x00000000 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Status_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal138_tmp_var;
	BM_L3L4CompleteHeader_Status_GET( base_ptr, bmlocal138_tmp_var );
	return bmlocal138_tmp_var;
}

#define BM_L3L4CompleteHeader_Status_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal139_my_ptr;\
	UINT bmlocal140_my_bitoff;\
	BM_L3L4CompleteHeader_Status_GET_POS( base_ptr, bmlocal139_my_ptr, bmlocal140_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal139_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal139_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal139_my_ptr, bmlocal140_my_bitoff, 16, in_val, 0x00000000 );\
	}\
}

// L3L4CompleteHeader_Status: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Status: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Status: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Status: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Status: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Status: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Status_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal141_out_val;\
	BM_L3L4CompleteHeader_Status_GET( base_ptr, bmlocal141_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Status", 16, (UINT)(bmlocal141_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Status_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Status_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Status_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal142_my_ptr;\
	UINT bmlocal143_my_bitoff;\
	BM_L3L4CompleteHeader_Status_GET_POS( base_ptr, bmlocal142_my_ptr, bmlocal143_my_bitoff );\
	(*((UINT16*)bmlocal142_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal143_my_bitoff );\
}

// L3L4CompleteHeader_Status: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Status_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal144_tmp_bits;\
	BM_L3L4CompleteHeader_Status_GET_SIZE( base_ptr, out_bytes, bmlocal144_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal144_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Status_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_Reserved2_GET_POS( base_ptr, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal147_acc_bytes;\
	UINT bmlocal148_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = 0;\
	bmlocal147_acc_bytes = 10;\
	bmlocal148_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal147_acc_bytes );\
	out_bitoff += bmlocal148_acc_bits;\
}

#define BM_L3L4CompleteHeader_Reserved2_GET_POS_ALIGNED( base_ptr, out_ptr )\
{\
	/*lint --e{*} */\
	UINT bmlocal149_tmp_bitoff;\
	BM_L3L4CompleteHeader_Reserved2_GET_POS( base_ptr, out_ptr, bmlocal149_tmp_bitoff );\
	BMI_NORMALIZE_BITOFF(out_ptr, bmlocal149_tmp_bitoff);\
}

#define BM_L3L4CompleteHeader_Reserved2_POS_ALIGNED 10

// Alignment of L3L4CompleteHeader_Reserved2: accumulated=(2,0, ABA=4), parent.base=(0,0, ABA=4)
#define BM_L3L4CompleteHeader_Reserved2_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_Reserved2_GET( base_ptr, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal150_my_ptr;\
	UINT bmlocal151_my_bitoff;\
	BM_L3L4CompleteHeader_Reserved2_GET_POS( base_ptr, bmlocal150_my_ptr, bmlocal151_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal150_my_ptr)) ), 0, 16, 0);\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		(out_val) = (UINT16)BMI_32BIT_EXTRACT( (BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal150_my_ptr)) ), 0, 16, 0);\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_GET( bmlocal150_my_ptr, bmlocal151_my_bitoff, 16, UINT16, out_val, 0x00000002 );\
	}\
}

BMI_INLINE UINT16 BM_INLINE_L3L4CompleteHeader_Reserved2_GET(PVOID base_ptr)
{
	/*lint --e{*} */
	UINT16 bmlocal152_tmp_var;
	BM_L3L4CompleteHeader_Reserved2_GET( base_ptr, bmlocal152_tmp_var );
	return bmlocal152_tmp_var;
}

#define BM_L3L4CompleteHeader_Reserved2_SET( base_ptr, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal153_my_ptr;\
	UINT bmlocal154_my_bitoff;\
	BM_L3L4CompleteHeader_Reserved2_GET_POS( base_ptr, bmlocal153_my_ptr, bmlocal154_my_bitoff );\
	if( BMI_MACHINE_ARM_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal153_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else if( BMI_MACHINE_INTEL_LITTLE == BMI_MACHINE_VALUE )\
	{\
		BMI_32BIT_CLEAR_ASSIGN_TYPE( BMI_GET_16BIT_PTR_CONTENTS( BMI_PTR_TO_NUMERIC_CAST(bmlocal153_my_ptr) ), (in_val), 0, 0, 16, UINT16 );\
	}\
	else\
	{\
		BMI_GENERIC_32BIT_LITTLE_SET( bmlocal153_my_ptr, bmlocal154_my_bitoff, 16, in_val, 0x00000002 );\
	}\
}

// L3L4CompleteHeader_Reserved2: IS_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Reserved2: SET_DEFAULT accessor is not defined because no default value was specified.
// L3L4CompleteHeader_Reserved2: IS_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Reserved2: SET_RESET accessor is not defined because no reset value was specified.
// L3L4CompleteHeader_Reserved2: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// L3L4CompleteHeader_Reserved2: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_L3L4CompleteHeader_Reserved2_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal155_out_val;\
	BM_L3L4CompleteHeader_Reserved2_GET( base_ptr, bmlocal155_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Reserved2", 16, (UINT)(bmlocal155_out_val), "%d", 1);\
}

#define BM_L3L4CompleteHeader_Reserved2_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_Reserved2_DUMP_DEPTH( base_ptr, 0 );\
}

#define BM_L3L4CompleteHeader_Reserved2_INCREMENT( base_ptr )\
{\
	/*lint --e{*} */\
	PVOID bmlocal156_my_ptr;\
	UINT bmlocal157_my_bitoff;\
	BM_L3L4CompleteHeader_Reserved2_GET_POS( base_ptr, bmlocal156_my_ptr, bmlocal157_my_bitoff );\
	(*((UINT16*)bmlocal156_my_ptr))++;\
	BMI_UNUSED_VAR( bmlocal157_my_bitoff );\
}

// L3L4CompleteHeader_Reserved2: Validation accessors are not defined because validation condition was not specified.
#define BM_L3L4CompleteHeader_Reserved2_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal158_tmp_bits;\
	BM_L3L4CompleteHeader_Reserved2_GET_SIZE( base_ptr, out_bytes, bmlocal158_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal158_tmp_bits );\
}

#define BM_L3L4CompleteHeader_Reserved2_BYTES_SIZE 2

#define BM_L3L4CompleteHeader_GET_SIZE( base_ptr, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 12;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_GET_BYTES_SIZE( base_ptr, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal161_tmp_bits;\
	BM_L3L4CompleteHeader_GET_SIZE( base_ptr, out_bytes, bmlocal161_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal161_tmp_bits );\
}

#define BM_L3L4CompleteHeader_BYTES_SIZE 12

#define BM_L3L4CompleteHeader_DUMP_DEPTH( base_ptr, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "L3L4CompleteHeader", 1);\
	BM_L3L4CompleteHeader_Type_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_L3L4CompleteHeader_Length_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_L3L4CompleteHeader_Version_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_L3L4CompleteHeader_Accessibility_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_L3L4CompleteHeader_Status_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BM_L3L4CompleteHeader_Reserved2_DUMP_DEPTH( base_ptr, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
}

#define BM_L3L4CompleteHeader_DUMP( base_ptr )\
{\
	/*lint --e{*} */\
	BM_L3L4CompleteHeader_DUMP_DEPTH( base_ptr, 0 );\
}


typedef UINT8 ChannelInfoArray[24];

/*lint -save -e806 */ /* Small bit field is signed rather than unsigned*/
#ifdef BMI_ENDIANNESS_LITTLE
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT32 _Frequency;
	UINT16 _ChannelId : 16;
	UINT8 _Bandwidth : 8;
	UINT8 _Fft : 8;
	BMS_LittleEndianness_Uint8 _Preambles[15];
	UINT8 _Reserved : 8;
} BMS_ChannelInfoArray;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#else /* BMI_ENDIANNESS_BIG */
#if (!defined __arm && !defined __arc)
#pragma pack( push, 1 )
#endif
#ifdef __arm
typedef __packed struct
#elif defined __arc
typedef _Packed struct
#else
typedef struct
#endif
{
	UINT8 _Reserved : 8;
	BMS_LittleEndianness_Uint8 _Preambles[15];
	UINT8 _Fft : 8;
	UINT8 _Bandwidth : 8;
	UINT16 _ChannelId : 16;
	UINT32 _Frequency;
} BMS_ChannelInfoArray;

#if (!defined __arm && !defined __arc)
#pragma pack( pop )
#endif

#endif	/*#ifdef BMI_ENDIANNESS_LITTLE*/
/*lint -restore */

// COMPOSITE: Full name: 'ChannelInfoArray' Type: 'ChannelInfoArray', Top-level, Non-instance, Including bitoff root
#define BM_ChannelInfoArray_Frequency_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
}

// Alignment of ChannelInfoArray_Frequency: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_Frequency_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 4;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Frequency_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal162_my_ptr;\
	UINT bmlocal163_my_bitoff;\
	BM_ChannelInfoArray_Frequency_GET_POS( base_ptr, base_bitoff, bmlocal162_my_ptr, bmlocal163_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal162_my_ptr, bmlocal163_my_bitoff, 32, UINT32, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT32 BM_INLINE_ChannelInfoArray_Frequency_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT32 bmlocal164_tmp_var;
	BM_ChannelInfoArray_Frequency_GET( base_ptr, base_bitoff, bmlocal164_tmp_var );
	return bmlocal164_tmp_var;
}

#define BM_ChannelInfoArray_Frequency_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal165_my_ptr;\
	UINT bmlocal166_my_bitoff;\
	BM_ChannelInfoArray_Frequency_GET_POS( base_ptr, base_bitoff, bmlocal165_my_ptr, bmlocal166_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal165_my_ptr, bmlocal166_my_bitoff, 32, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_Frequency: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Frequency: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Frequency: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Frequency: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Frequency: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_Frequency: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_Frequency_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal167_out_val;\
	BM_ChannelInfoArray_Frequency_GET( base_ptr, base_bitoff, bmlocal167_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Frequency", 32, (UINT)(bmlocal167_out_val), "%d", 1);\
}

#define BM_ChannelInfoArray_Frequency_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Frequency_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_Frequency_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT32 bmlocal168_val;\
	BM_ChannelInfoArray_Frequency_GET( base_ptr, base_bitoff, bmlocal168_val );\
	(bmlocal168_val)++;\
	BM_ChannelInfoArray_Frequency_SET( base_ptr, base_bitoff, bmlocal168_val );\
}

// ChannelInfoArray_Frequency: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_Frequency_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal169_tmp_bits;\
	BM_ChannelInfoArray_Frequency_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal169_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal169_tmp_bits );\
}

#define BM_ChannelInfoArray_Frequency_BYTES_SIZE 4

#define BM_ChannelInfoArray_ChannelId_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal172_acc_bytes;\
	UINT bmlocal173_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
	bmlocal172_acc_bytes = 4;\
	bmlocal173_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal172_acc_bytes );\
	out_bitoff += bmlocal173_acc_bits;\
}

// Alignment of ChannelInfoArray_ChannelId: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_ChannelId_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 2;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_ChannelId_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal174_my_ptr;\
	UINT bmlocal175_my_bitoff;\
	BM_ChannelInfoArray_ChannelId_GET_POS( base_ptr, base_bitoff, bmlocal174_my_ptr, bmlocal175_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal174_my_ptr, bmlocal175_my_bitoff, 16, UINT16, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT16 BM_INLINE_ChannelInfoArray_ChannelId_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT16 bmlocal176_tmp_var;
	BM_ChannelInfoArray_ChannelId_GET( base_ptr, base_bitoff, bmlocal176_tmp_var );
	return bmlocal176_tmp_var;
}

#define BM_ChannelInfoArray_ChannelId_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal177_my_ptr;\
	UINT bmlocal178_my_bitoff;\
	BM_ChannelInfoArray_ChannelId_GET_POS( base_ptr, base_bitoff, bmlocal177_my_ptr, bmlocal178_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal177_my_ptr, bmlocal178_my_bitoff, 16, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_ChannelId: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_ChannelId: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_ChannelId: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_ChannelId: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_ChannelId: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_ChannelId: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_ChannelId_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal179_out_val;\
	BM_ChannelInfoArray_ChannelId_GET( base_ptr, base_bitoff, bmlocal179_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "ChannelId", 16, (UINT)(bmlocal179_out_val), "%d", 1);\
}

#define BM_ChannelInfoArray_ChannelId_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_ChannelId_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_ChannelId_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT16 bmlocal180_val;\
	BM_ChannelInfoArray_ChannelId_GET( base_ptr, base_bitoff, bmlocal180_val );\
	(bmlocal180_val)++;\
	BM_ChannelInfoArray_ChannelId_SET( base_ptr, base_bitoff, bmlocal180_val );\
}

// ChannelInfoArray_ChannelId: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_ChannelId_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal181_tmp_bits;\
	BM_ChannelInfoArray_ChannelId_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal181_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal181_tmp_bits );\
}

#define BM_ChannelInfoArray_ChannelId_BYTES_SIZE 2

#define BM_ChannelInfoArray_Bandwidth_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal184_acc_bytes;\
	UINT bmlocal185_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
	bmlocal184_acc_bytes = 6;\
	bmlocal185_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal184_acc_bytes );\
	out_bitoff += bmlocal185_acc_bits;\
}

// Alignment of ChannelInfoArray_Bandwidth: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_Bandwidth_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Bandwidth_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal186_my_ptr;\
	UINT bmlocal187_my_bitoff;\
	BM_ChannelInfoArray_Bandwidth_GET_POS( base_ptr, base_bitoff, bmlocal186_my_ptr, bmlocal187_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal186_my_ptr, bmlocal187_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_ChannelInfoArray_Bandwidth_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT8 bmlocal188_tmp_var;
	BM_ChannelInfoArray_Bandwidth_GET( base_ptr, base_bitoff, bmlocal188_tmp_var );
	return bmlocal188_tmp_var;
}

#define BM_ChannelInfoArray_Bandwidth_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal189_my_ptr;\
	UINT bmlocal190_my_bitoff;\
	BM_ChannelInfoArray_Bandwidth_GET_POS( base_ptr, base_bitoff, bmlocal189_my_ptr, bmlocal190_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal189_my_ptr, bmlocal190_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_Bandwidth: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Bandwidth: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Bandwidth: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Bandwidth: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Bandwidth: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_Bandwidth: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_Bandwidth_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal191_out_val;\
	BM_ChannelInfoArray_Bandwidth_GET( base_ptr, base_bitoff, bmlocal191_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Bandwidth", 8, (UINT)(bmlocal191_out_val), "%d", 1);\
}

#define BM_ChannelInfoArray_Bandwidth_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Bandwidth_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_Bandwidth_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal192_val;\
	BM_ChannelInfoArray_Bandwidth_GET( base_ptr, base_bitoff, bmlocal192_val );\
	(bmlocal192_val)++;\
	BM_ChannelInfoArray_Bandwidth_SET( base_ptr, base_bitoff, bmlocal192_val );\
}

// ChannelInfoArray_Bandwidth: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_Bandwidth_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal193_tmp_bits;\
	BM_ChannelInfoArray_Bandwidth_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal193_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal193_tmp_bits );\
}

#define BM_ChannelInfoArray_Bandwidth_BYTES_SIZE 1

#define BM_ChannelInfoArray_Fft_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal196_acc_bytes;\
	UINT bmlocal197_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
	bmlocal196_acc_bytes = 7;\
	bmlocal197_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal196_acc_bytes );\
	out_bitoff += bmlocal197_acc_bits;\
}

// Alignment of ChannelInfoArray_Fft: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_Fft_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Fft_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal198_my_ptr;\
	UINT bmlocal199_my_bitoff;\
	BM_ChannelInfoArray_Fft_GET_POS( base_ptr, base_bitoff, bmlocal198_my_ptr, bmlocal199_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal198_my_ptr, bmlocal199_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_ChannelInfoArray_Fft_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT8 bmlocal200_tmp_var;
	BM_ChannelInfoArray_Fft_GET( base_ptr, base_bitoff, bmlocal200_tmp_var );
	return bmlocal200_tmp_var;
}

#define BM_ChannelInfoArray_Fft_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal201_my_ptr;\
	UINT bmlocal202_my_bitoff;\
	BM_ChannelInfoArray_Fft_GET_POS( base_ptr, base_bitoff, bmlocal201_my_ptr, bmlocal202_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal201_my_ptr, bmlocal202_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_Fft: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Fft: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Fft: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Fft: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Fft: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_Fft: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_Fft_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal203_out_val;\
	BM_ChannelInfoArray_Fft_GET( base_ptr, base_bitoff, bmlocal203_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Fft", 8, (UINT)(bmlocal203_out_val), "%d", 1);\
}

#define BM_ChannelInfoArray_Fft_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Fft_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_Fft_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal204_val;\
	BM_ChannelInfoArray_Fft_GET( base_ptr, base_bitoff, bmlocal204_val );\
	(bmlocal204_val)++;\
	BM_ChannelInfoArray_Fft_SET( base_ptr, base_bitoff, bmlocal204_val );\
}

// ChannelInfoArray_Fft: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_Fft_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal205_tmp_bits;\
	BM_ChannelInfoArray_Fft_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal205_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal205_tmp_bits );\
}

#define BM_ChannelInfoArray_Fft_BYTES_SIZE 1

#define BM_ChannelInfoArray_Preambles_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal208_acc_bytes;\
	UINT bmlocal209_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
	bmlocal208_acc_bytes = 8;\
	bmlocal209_acc_bits = 0;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal208_acc_bytes );\
	out_bitoff += bmlocal209_acc_bits;\
}

// ARRAY: ChannelInfoArray_Preambles
#define BM_ChannelInfoArray_Preambles_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 15;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

BMI_INLINE UINT BM_INLINE_ChannelInfoArray_Preambles_GET_SIZE()
{
	/*lint --e{*} */
	return 15;
}

#define BM_ChannelInfoArray_Preambles_GET_DIMENSION_ELEMENT_COUNT( base_ptr, base_bitoff, index, out_element_count )\
{\
	/*lint --e{*} */\
	switch( index )\
	{\
		case (0):\
		out_element_count = 15;\
		break;\
		default:\
		out_element_count = 0;\
		break;\
	}\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Preambles_GET_ELEMENT_POS( base_ptr, base_bitoff, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal210_out_ptr;\
	UINT bmlocal211_out_bitoff;\
	UINT bmlocal212_element_size_bytes;\
	UINT bmlocal213_element_size_bits;\
	BM_ChannelInfoArray_Preambles_GET_POS( base_ptr, base_bitoff, bmlocal210_out_ptr, bmlocal211_out_bitoff );\
	bmlocal212_element_size_bytes = 1;\
	bmlocal213_element_size_bits = 0;\
	out_ptr = BMI_NUMBER_TO_PTR_CAST( BMI_PTR_TO_NUMERIC_CAST(bmlocal210_out_ptr) + (idx0) * bmlocal212_element_size_bytes );\
	out_bitoff = bmlocal211_out_bitoff;\
	BMI_UNUSED_VAR( bmlocal213_element_size_bits );\
}

// COMPOSITE: Full name: 'ChannelInfoArray_Preambles' Type: 'Uint8', Inner, Non-instance, Including bitoff root
#define BM_ChannelInfoArray_Preambles_value_GET_POS( base_ptr, base_bitoff, idx0, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	PVOID bmlocal214_parent_out_ptr;\
	BM_ChannelInfoArray_Preambles_GET_ELEMENT_POS( base_ptr, base_bitoff, idx0, bmlocal214_parent_out_ptr, out_bitoff );\
	out_ptr = bmlocal214_parent_out_ptr;\
}

// Alignment of ChannelInfoArray_Preambles_value: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_Preambles_value_GET_SIZE( base_ptr, base_bitoff, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChannelInfoArray_Preambles_value_GET( base_ptr, base_bitoff, idx0, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal215_my_ptr;\
	UINT bmlocal216_my_bitoff;\
	BM_ChannelInfoArray_Preambles_value_GET_POS( base_ptr, base_bitoff, idx0, bmlocal215_my_ptr, bmlocal216_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal215_my_ptr, bmlocal216_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_ChannelInfoArray_Preambles_value_GET(PVOID base_ptr, UINT base_bitoff, UINT idx0)
{
	/*lint --e{*} */
	UINT8 bmlocal217_tmp_var;
	BM_ChannelInfoArray_Preambles_value_GET( base_ptr, base_bitoff, idx0, bmlocal217_tmp_var );
	return bmlocal217_tmp_var;
}

#define BM_ChannelInfoArray_Preambles_value_SET( base_ptr, base_bitoff, idx0, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal218_my_ptr;\
	UINT bmlocal219_my_bitoff;\
	BM_ChannelInfoArray_Preambles_value_GET_POS( base_ptr, base_bitoff, idx0, bmlocal218_my_ptr, bmlocal219_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal218_my_ptr, bmlocal219_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_Preambles_value: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Preambles_value: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Preambles_value: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Preambles_value: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Preambles_value: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_Preambles_value: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_Preambles_value_DUMP_DEPTH( base_ptr, base_bitoff, idx0, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal220_out_val;\
	BM_ChannelInfoArray_Preambles_value_GET( base_ptr, base_bitoff, idx0, bmlocal220_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "value", 8, (UINT)(bmlocal220_out_val), "%u", 1);\
}

#define BM_ChannelInfoArray_Preambles_value_DUMP( base_ptr, base_bitoff, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Preambles_value_DUMP_DEPTH( base_ptr, base_bitoff, idx0, 0 );\
}

#define BM_ChannelInfoArray_Preambles_value_INCREMENT( base_ptr, base_bitoff, idx0 )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal221_val;\
	BM_ChannelInfoArray_Preambles_value_GET( base_ptr, base_bitoff, idx0, bmlocal221_val );\
	(bmlocal221_val)++;\
	BM_ChannelInfoArray_Preambles_value_SET( base_ptr, base_bitoff, idx0, bmlocal221_val );\
}

// ChannelInfoArray_Preambles_value: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_Preambles_value_GET_BYTES_SIZE( base_ptr, base_bitoff, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal222_tmp_bits;\
	BM_ChannelInfoArray_Preambles_value_GET_SIZE( base_ptr, base_bitoff, idx0, out_bytes, bmlocal222_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal222_tmp_bits );\
}

#define BM_ChannelInfoArray_Preambles_value_BYTES_SIZE 1

#define BM_ChannelInfoArray_Preambles_GET_CELL_SIZE( base_ptr, base_bitoff, idx0, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChannelInfoArray_Preambles_GET_BYTES_CELL_SIZE( base_ptr, base_bitoff, idx0, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal225_tmp_bits;\
	BM_ChannelInfoArray_Preambles_GET_CELL_SIZE( base_ptr, base_bitoff, idx0, out_bytes, bmlocal225_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal225_tmp_bits );\
}

#define BM_ChannelInfoArray_Preambles_BYTES_CELL_SIZE 1

BMI_INLINE UINT BM_INLINE_ChannelInfoArray_Preambles_GET_CELL_SIZE()
{
	/*lint --e{*} */
	return 1;
}

#define BM_ChannelInfoArray_Preambles_DUMP_DEPTH_IDX( base_ptr, base_bitoff, idx0, depth )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Preambles_value_DUMP_DEPTH( base_ptr, base_bitoff, idx0, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
	BMI_UNUSED_VAR( idx0 );\
}

#define BM_ChannelInfoArray_Preambles_DUMP_IDX( base_ptr, base_bitoff, idx0 )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Preambles_DUMP_DEPTH_IDX( base_ptr, base_bitoff, idx0, 0 );\
}

#define BM_ChannelInfoArray_Preambles_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT bmlocal226_dim_size0;\
	UINT bmlocal227_idx0;\
	bmlocal226_dim_size0 = 15;\
	BMI_FORMAT_NONVALUE_DUMP(depth, "Preambles", 1);\
	for( bmlocal227_idx0=0; bmlocal227_idx0<bmlocal226_dim_size0; bmlocal227_idx0++ )\
	{\
		BMI_FORMAT_NONVALUE_DUMP((depth + 1), "(", 0);\
		/*lint -e(571) */\
		BMI_FORMAT_DUMP(0, "", 32, (UINT)(bmlocal227_idx0), "%d", 0);\
		BMI_FORMAT_NONVALUE_DUMP(0, ")", 1);\
		BM_ChannelInfoArray_Preambles_DUMP_DEPTH_IDX( base_ptr, base_bitoff, bmlocal227_idx0, depth );\
	}\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Preambles_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Preambles_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_Preambles_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal228_tmp_bits;\
	BM_ChannelInfoArray_Preambles_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal228_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal228_tmp_bits );\
}

#define BM_ChannelInfoArray_Preambles_BYTES_SIZE 15

#define BM_ChannelInfoArray_Reserved_GET_POS( base_ptr, base_bitoff, out_ptr, out_bitoff )\
{\
	/*lint --e{*} */\
	UINT bmlocal229_tmp_bytes = 0;\
	UINT bmlocal230_tmp_bits = 0;\
	UINT bmlocal231_acc_bytes;\
	UINT bmlocal232_acc_bits;\
	out_ptr = base_ptr;\
	out_bitoff = base_bitoff;\
	bmlocal231_acc_bytes = 8;\
	bmlocal232_acc_bits = 0;\
	BM_ChannelInfoArray_Preambles_GET_SIZE( base_ptr, base_bitoff, bmlocal229_tmp_bytes, bmlocal230_tmp_bits );\
	bmlocal231_acc_bytes += bmlocal229_tmp_bytes;\
	bmlocal232_acc_bits += bmlocal230_tmp_bits;\
	BMI_ADD_ASSIGN_PTR( out_ptr, bmlocal231_acc_bytes );\
	out_bitoff += bmlocal232_acc_bits;\
}

// Alignment of ChannelInfoArray_Reserved: accumulated=(Variable), parent.base=(Variable)
#define BM_ChannelInfoArray_Reserved_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	out_bytes = 1;\
	out_bits = 0;\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_Reserved_GET( base_ptr, base_bitoff, out_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal233_my_ptr;\
	UINT bmlocal234_my_bitoff;\
	BM_ChannelInfoArray_Reserved_GET_POS( base_ptr, base_bitoff, bmlocal233_my_ptr, bmlocal234_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_GET( bmlocal233_my_ptr, bmlocal234_my_bitoff, 8, UINT8, out_val, 0xFFFFFFFF );\
}

BMI_INLINE UINT8 BM_INLINE_ChannelInfoArray_Reserved_GET(PVOID base_ptr, UINT base_bitoff)
{
	/*lint --e{*} */
	UINT8 bmlocal235_tmp_var;
	BM_ChannelInfoArray_Reserved_GET( base_ptr, base_bitoff, bmlocal235_tmp_var );
	return bmlocal235_tmp_var;
}

#define BM_ChannelInfoArray_Reserved_SET( base_ptr, base_bitoff, in_val )\
{\
	/*lint --e{*} */\
	PVOID bmlocal236_my_ptr;\
	UINT bmlocal237_my_bitoff;\
	BM_ChannelInfoArray_Reserved_GET_POS( base_ptr, base_bitoff, bmlocal236_my_ptr, bmlocal237_my_bitoff );\
	BMI_GENERIC_32BIT_LITTLE_SET( bmlocal236_my_ptr, bmlocal237_my_bitoff, 8, in_val, 0xFFFFFFFF );\
}

// ChannelInfoArray_Reserved: IS_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Reserved: SET_DEFAULT accessor is not defined because no default value was specified.
// ChannelInfoArray_Reserved: IS_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Reserved: SET_RESET accessor is not defined because no reset value was specified.
// ChannelInfoArray_Reserved: CLEAR accessor is not defined because of incompatible access rights. Specified: RW Required: W1C, WO1C.
// ChannelInfoArray_Reserved: SET(W1S) accessor is not defined because of incompatible access rights. Specified: RW Required: W1S, WO1S.
#define BM_ChannelInfoArray_Reserved_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal238_out_val;\
	BM_ChannelInfoArray_Reserved_GET( base_ptr, base_bitoff, bmlocal238_out_val );\
	/*lint -e(571) */\
	BMI_FORMAT_DUMP(depth, "Reserved", 8, (UINT)(bmlocal238_out_val), "%d", 1);\
}

#define BM_ChannelInfoArray_Reserved_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_Reserved_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}

#define BM_ChannelInfoArray_Reserved_INCREMENT( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	UINT8 bmlocal239_val;\
	BM_ChannelInfoArray_Reserved_GET( base_ptr, base_bitoff, bmlocal239_val );\
	(bmlocal239_val)++;\
	BM_ChannelInfoArray_Reserved_SET( base_ptr, base_bitoff, bmlocal239_val );\
}

// ChannelInfoArray_Reserved: Validation accessors are not defined because validation condition was not specified.
#define BM_ChannelInfoArray_Reserved_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal240_tmp_bits;\
	BM_ChannelInfoArray_Reserved_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal240_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal240_tmp_bits );\
}

#define BM_ChannelInfoArray_Reserved_BYTES_SIZE 1

#define BM_ChannelInfoArray_GET_SIZE( base_ptr, base_bitoff, out_bytes, out_bits )\
{\
	/*lint --e{*} */\
	UINT bmlocal241_tmp_bytes = 0;\
	UINT bmlocal242_tmp_bits = 0;\
	out_bytes = 9;\
	out_bits = 0;\
	BM_ChannelInfoArray_Preambles_GET_SIZE( base_ptr, base_bitoff, bmlocal241_tmp_bytes, bmlocal242_tmp_bits );\
	out_bytes += bmlocal241_tmp_bytes;\
	out_bits += bmlocal242_tmp_bits;\
}

#define BM_ChannelInfoArray_GET_BYTES_SIZE( base_ptr, base_bitoff, out_bytes )\
{\
	/*lint --e{*} */\
	UINT bmlocal243_tmp_bits;\
	BM_ChannelInfoArray_GET_SIZE( base_ptr, base_bitoff, out_bytes, bmlocal243_tmp_bits );\
	BMI_ROUND_UP_1BYTES( out_bytes, bmlocal243_tmp_bits );\
}

#define BM_ChannelInfoArray_BYTES_SIZE 24

#define BM_ChannelInfoArray_DUMP_DEPTH( base_ptr, base_bitoff, depth )\
{\
	/*lint --e{*} */\
	BMI_FORMAT_NONVALUE_DUMP(depth, "ChannelInfoArray", 1);\
	BM_ChannelInfoArray_Frequency_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BM_ChannelInfoArray_ChannelId_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BM_ChannelInfoArray_Bandwidth_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BM_ChannelInfoArray_Fft_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BM_ChannelInfoArray_Preambles_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BM_ChannelInfoArray_Reserved_DUMP_DEPTH( base_ptr, base_bitoff, (depth + 1) );\
	BMI_UNUSED_VAR( base_ptr );\
	BMI_UNUSED_VAR( base_bitoff );\
}

#define BM_ChannelInfoArray_DUMP( base_ptr, base_bitoff )\
{\
	/*lint --e{*} */\
	BM_ChannelInfoArray_DUMP_DEPTH( base_ptr, base_bitoff, 0 );\
}


/*lint --flb */

#endif /* _BITMAN_L4COMMON_H_ */

